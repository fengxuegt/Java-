/*
 * Created 2024-05-04 12:46:41
 * Author : fengxuegt
 * Email : fengxuegt@163.com
 */

## 2.1 整数的二进制表示与位运算
整数的每个位置都有一个位权；从右到左，第一位为1，然后向左依次乘10；

### 2.1.1 正整数的二进制表示
与十进制相同，只是位权变成了2的多次幂；

### 2.1.2 负整数的二进制表示
二进制用最高位表示符号位；使用补码表示法；这部分查看csapp第二章能完整解答；
整数运算导致溢出的时候就会变成负数；

### 2.1.3 十六进制
Java7之前一直不允许直接写二进制字面值，需要在前面补0，补足8位。然后用16进制表示。Java7开始支持二进制常量，在前面添加0b或者0B即可；
`int a = 0b11001;`

在Java中，能够方便的使用Integer和Long的方法查看整数的二进制和十六进制表示；
```java
System.out.println(Integer.toBinaryString(a)); //二进制
System.out.println(Integer.toHexString(a)); //十六进制
System.out.println(Long.toBinaryString(a)); //二进制
System.out.println(Long.toHexString(a)); //十六进制
```
## 2.2 小数的二进制表示
### 2.2.1 小数计算为什么会出错
因为二级制是无法精确表示很多小数的，只能够精确的表示2的多次幂的和的数字；

### 2.2.2 二进制表示
IEEE 754标准表示小数；这里也请参考csapp第二章
如果想查看浮点数二进制编码，可以使用如下代码：
```java
Integer.toBinaryString(Float.floatToIntBits(value))
Long.toBinaryString(Double.doubleToLongBits(value));
```
基本用法是先将小数转换成整数，然后再转化成二进制打印输出；

## 2.3 字符的编码与乱码
编码有两大类，一类是Unicode编码，一类是非Unicode编码；
### 2.3.1 常见非Unicode编码
**Ascii**
数字32-126表示的字符都是可打印字符；
其他字符编码为了保证和ascii的兼容性，一般都是将最高位设置为1，也就是说如果最高位为0，那就是ascii码，如果是1那就是各国自己的编码；

### 2.3.2 unicode编码
unicode主要做了这么一件事，就是给所有字符分配了唯一数字编码。unicode编码本身只规定了每个字符的数字编号是多少，至于数字编号如何对应二进制，有多种方案，分别是utf-32、utf-16、utf-8
**utf-8**
常用的是utf-8编码；使用变长字节表示，每个字符使用的字节个数与其unicode编号的大小有关，编号小的使用的字节就少，编号大的使用字节就多；使用的字节数1-4不等；

### 2.3.3 编码转换
编码转换改变了字符的二进制内容，但并没有改变字符看上去的样子；

### 2.3.4 乱码的原因
**解析错误**
切换查看编码的方式并没有改变数据的二进制本身，而只是改变了解析数据的方式；

**错误的解析和编码转换**
是在错误解析的基础上，进行了编码转换；

### 2.3.5 从乱码中恢复
基本思路是尝试逆向恢复；

## 2.4 char的真正含义
char本质上是一个固定占用两个字节的无符号整数，这个正整数对应Unicode编号，用于表示Unicode编号对应的字符；

