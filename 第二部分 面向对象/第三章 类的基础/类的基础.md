/*
 * Created 2024-05-05 20:44:10
 * Author : fengxuegt
 * Email : fengxuegt@163.com
 */

## 3.1 类的基本概念
### 3.1.1 函数容器
可以通过private关键字避免函数被外部调用。封装和隐藏内部实现细节。

### 3.1.2 自定义数据类型
一个数据类型由四部分组成：
- 类型本身具有的属性
- 类型本身可以进行的操作
- 类型实例具有的属性
- 类型实例可以进行的操作

**类变量**
类型本身所具有的变量；可以直接通过类名访问；
final关键字表示赋值之后不能再修改了，表示常量；
表示类变量的时候，static修饰符是必须的，public和static都不是

**实例变量和实例方法**
具体的对象具有的属性；

### 3.1.4 定义一个类
Java在创建对象的时候，所有的实例变量会分配一个默认值；

### 3.1.5 变量默认值
创建对象的时候有默认值，如果希望修改，可以在定义变量的同时就赋值；
static代码块的代码会在类加载的时候执行，在任何对象创建之前，并且只执行一次；

### 3.1.6 private变量
为了封装，会写set和get函数

### 3.1.7 构造方法
- 方法名和类名相同
- 没有返回值
this可以在构造方法中调用其他构造方法；（构造方法有重载）同时这行代码必须放在第一行，这是为了防止误操作；避免自己初始化了一通最后调用this其他方法把自己的初始化给覆盖掉；
new Point()；
- 分配内存
- 给实例设置默认值
- 执行构造函数

**默认构造方法**
每个类都至少要有一个构造方法；
在没有自定义构造方法的时候编译器会自动生成一个无参构造方法；

**私有构造方法**
- 不能构造实例的类，类只能被静态访问，例如Math和Arrays类
- 能创建实例，但是只能被类的静态方法调用
- 只用于被其他构造函数调用

### 3.1.8 类和对象的生命周期
new对象或者直接通过类名访问类变量和类方法时
Java会将类加载进内存，为这个类分配一块空间，这个空间包含类的定义、变量和方法，同时还有类的静态变量，并对静态变量赋初始值；

类只会加载一次，因此静态变量在内存中只有一份；

当通过new创建一个对象的时候，对象产生，在内存中会存储这个对象的实例变量，每个对象的实例变量是独立的；
每个对象除了保存实例变量的值以外，还会保存对应类型即类的地址，这样通过地址能够找到对应的类，访问类变量和方法代码；

## 3.2 类的组合
这节基本是一些例子的举例


## 3.3 代码的组织机制
### 3.3.1 包的概念
**声明类所在的包**
包声明必须位于源代码的最前面；
不同包合作开发；
**通过包使用类**
- import引入并不会递归
- 有一种特殊类型的导入，称为静态导入，它有一个static关键字，可以直接导入类的公开静态方法和成员；
```java
import static java.lang.System.out;
... // 代码
out.println(Arrays.toString(arr)); 
... // 代码
```
静态导入不应该过度使用，因为会难以区分访问的是哪个类的代码；

**包范围可见性**
默认访问权限是包可见；同一个包指的是同一个直接包，子包下的类并不能访问；
总结来说：private < default < protected < public

### 3.3.2 jar包
打包后提供给第三方；将jar包加入类路径即可使用；

### 3.3.3 程序的编译和连接
编译：javac 源代码 到 .class 文件
链接：根据引用到的类加载对应的字节码执行

Java编译和运行时，都需要指定一个classpath，即类路径。类路径可以有多个，对于直接的class文件，路径是class文件的根目录；对于jar包，路径是jar包的完整名称；

Java运行时会根据类的完全限定名称寻找并加载类，寻找的方式就是在类路径中寻找，如果是class文件的根目录，则直接查看是否有对应的子目录及文件，如果是jar文件，需要首先在内存中解压，然后再查看；

总结来说，import是编译时概念，用于确定完全限定名，在运行时，只根据完全限定名寻找并记载类；编译和运行都依赖类路径，类路径中的jar文件会被解压用于寻找和加载类；
